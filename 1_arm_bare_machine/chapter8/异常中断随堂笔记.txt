1.8.1发生中断时会经历两个阶段：查找异常向量表进入7种模式中的某种异常模式（SOC外主要是IRQ[普通中断]和FIQ[快速中断]）；进入异常模式下后，通过寄存器找到具体的中断源，并处理对应的异常程序。
1.8.1.1查找异常向量表阶段处理某种异常模式下的处理函数过程中，要做以下x件事情：
保护现场：保存通用寄存器r0~r12和下一条指令的地址到sp栈空间（？？？为什么保存lr而不是直接保存pc到sp栈中？？？推断是ARM有流水线，pc的值比真正执行的代码地址+8，而lr保存的是当前真正执行的代码地址），s5pv210会自动保存cpsr寄存器
恢复现场：退出异常模式后，将sp栈空间保存的r0~r12放入当前模式的r0~r12寄存器，恢复cpsr，将下条指令的地址放到pc寄存器(r15)中
1.8.8.2 初始化中断控制器
第一阶段绑定异常向量表到对应的处理程序；
禁止所有中断（如果不禁止中断，则某个我们不感兴趣且未提供ISR的中断由于外部/自身的原因被触发，程序会查找对应的ISR，得到乱码，很可能导致程序跑飞。因此一般都是先禁止所有的中断，然后根据自己的需要，打开对应的中断，一旦打开，就需要为其提供ISR，并绑定到对应的VICnVECADDR）；
选择所有中断类型为IRQ；
清除当前正在处理的中断对应的处理函数地址(VICnADDR)。？？？为什么不清存放isr的寄存器VICnVECADDR呢？？？估计是VICnVECADDR寄存器有存放SOC内部中断的isr，清理VICnVECADDR的话，会导致SOC内部中断的isr被清理，SOC内部异常时，程序到VICnVECADDR中获取的isr是乱码，程序很可能会跑飞。
为什么在中断初始化的时候要禁止所有的中断？
因为一旦打开中断，由于外部或硬件自己的原因产生中断后，会自动寻找isr，而我们认为可能用不到上述中断，就没有提供对应的isr，这时程序拿到的就是一段乱码，很可能导致程序跑飞。
一般的做法是：先关掉所有的中断，再根据自己的需要，打开对应的中断。一旦打开，就必须给这个中断提供isr，将isr地址写入到VICnVECADDR寄存器中（也就是绑定ISR）。
1.8.8.3 中断的使能与禁止
中断使能：VICnINTENABLE。通过传参的intnum来使能某个具体的中断源，intnum在interrupt.h中有定义，是物理中断号
中断禁止：VICnINTENCLEAR
思路是先根据中断号(intnum)判断在VIC0~VIC3中的哪个寄存器，然后减去对应寄存器的偏移量(0、32、64、96),得到在对应寄存器中的偏移量i（0~31），然后在VICnINTENNABLE/VICnINTENCLEAR寄存器的i位置1，使能/禁止VIC寄存器的第i位
1.8.8.4 绑定自己实现的isr到VICnVECADDR
(1) 搞清楚VICnVECADDR寄存器和VICnADDR寄存器的区别
VICnVECADDR寄存器是用来存放isr地址的，也就是说，我们需要把isr写好，然后把地址放到VICnVECADDR寄存器中
VICnADDR寄存器是硬件自动操控的，当VICnVECADDR寄存器的某个isr被激活，硬件就会自动把这个isr的地址推入到VICnADDR寄存器中，方便我们查询使用。VICnDDR保存的是正在处理的中断的处理函数地址
总结：VICnVECADDR相当于一个向量表，存放了每个isr对应的地址；VICnADDR则自动存放被激活的某个isr（正在处理的中断的处理函数）的地址
(2) 根据中断号判断isr绑定到哪个VICVECADDR寄存器上，然后减去对应寄存器的偏移量(0、32、64、96)，得到在VIC寄存器上的偏移量i（0~31），然后在VIC(也就是对应寄存器数组(0~31*4)的首地址 + i * 4)上绑定isr地址即可。

1.8.8.5 真正的中断处理程序如何获取isr
根据VICnSTATUS查询不为0的VICnADDR，根据对应的VICADDR执行ISR

整个中断的流程处理步骤总结：
分为两个部分：
第一部分是为中断响应做的准备工作，包括：
初始化中断控制器（绑定异常向量表；禁止所有中断；选择所有终端类型为irq；清除所有VICVECADDR）；
绑定isr到中断控制器；
对应的中断控制器各项条件均使能。
第二部分是当硬件产生中断后，如何自动执行isr，包括：
通过异常向量表跳转到对应的异常处理函数；
保护现场；
确定哪个VIC寄存器产生了中断，然后去对应的VICADDR中取出isr，然后执行即可；
恢复现场；

1.8.11 中断方式处理外部按键编程实践
设置GPIO引脚为中断模式；设置中断触发模式；中断允许；清挂起；写中断程序isr
1.8.11.1 设置GPIO模式为外部中断模式(GPIOH0、GPIOH2)
1.8.11.2 设置中断触发模式(INT_CON)（高电平触发、低电平触发、上升沿触发、下降沿触发、双边沿触发）
EINT2、EINT3、EINT16、EINT17、EINT18、EINT19、
1.8.11.3 设置中断清除挂起(INT_PEND，写1是清除中断挂起，写0是中断挂起，此时中断等待CPU进行响应)、允许中断(INT_MASK)
1.8.11.4 编写中断处理程序isr(触发中断后的中断处理代码；清挂起；清除VICADDR)
1.8.11.5 按下按键触发相应中断，进行相应中断代码的运行
1.8.11.6 清除中断挂起
1.8.11.7 清除正在运行的中断的中断处理程序isr地址（VICnADDR寄存器）。




