4.3.1 指针初探
(1) 指针全称就是指针变量，和普通变量没有本质区别。编译器把一个内存和指针变量联系起来，只是这个内存天生就是用来存放另一个变量的地址的，
通过解引用的方法，就可以得到变量存放的另一个变量地址中所存放的变量值了。
(2) 指针使用的三步骤：定义指针变量；绑定指针变量；解引用
如果不绑定指针变量就解引用，大概率会出错。因为局部变量定义指针变量时，会在指针变量中随机存储一个地址，这个地址不可预知，不可控制，里面的内容也无法预测。所以定义变量后记得绑定它。

4.3.2 指针引出的符号的理解
4.3.2.1 *号 
*在C语言中有两种用法，一种用作乘法；另一种用作指针。
*用作指针时有两种用法：
一种用于和前面的类型结合，表明要定义的指针的类型（int *p1, *p2 表示p1和p2两个int类型指针）；第二种是解引用。解引用时，*p表示p指向的变量本身。

4.3.2.2 &		取址符

4.3.2.3 指针定义并初始化 和 指针定义后再初始化 的区别
(1) 指针变量定义时可以初始化，指针的初始化其实就是给指针变量赋值，这里天生用来赋地址值，即为指针变量绑定地址。
(2) 定义并初始化的格式为：int a = 23; int *p1 = &a;
(3) 定义指针后再初始化的格式为：int a = 23; int *p2; p2 = &a;

4.3.2.4 左值与右值
(1) 放在赋值运算符左边的变量就叫左值，右边的就叫右值。所以赋值操作其实就是：左值 = 右值
(2) 当一个变量做左值时，编译器认为这个变量符号的真实含义是这个变量所对应的那个内存空间；当一个变量做右值时，编译器认为这个变量符号的真实含义是这个变量对应的内存空间中存储的那个数。

4.3.3 野指针
4.3.3.1 野指针
(1) 野指针就是只进行了定义而没有初始化的指针变量。这时的指针变量存放的地址是随机的，分三种情况：(1)存放的地址不可访问(属于操作系统的空间)(2)存放的地址可以访问，且
不是进行正在使用的变量的地址(3)最可怕的一种，即存放的地址可以访问，但，这个地址指向的变量是进行运行中正在使用的变量，最终会导致程序的崩溃。
(2) 不管是上述哪一种情况，都是我们不想看到的。我们在编程并使用指针变量的时候，必须注意杜绝野指针的出现。步骤分3步：(1)定义指针的同时给指针赋初值NULL；(2)解引用前，给指针变量使用指针前，
绑定一个绝对可用的地址；(3)解引用指针的时候，先判断指针是否为NULL，不为NULL时，才对指针进行解引用；(4)指针使用完毕后，赋值NULL。总之，不使用指针时就保持指针是NULL。

4.3.3.2 什么是NULL
#ifdef _cplusplus
#define NULL 0
#else
#define NULL (void *)0
(1) 也就是说，C++环境下的NULL就是0；C环境下的NULL是强制类型转换为void *的0，即类型为void的指针变量，存储的是0的地址。

4.3.4 const关键字与指针
4.3.4.1 const修饰指针的4种形式
const int *p1;			//指向const int型的指针，指针变量指向的int变量无法修改
int const *p3;			//指向const int型的指针，指针变量指向int型的值，指向的值无法修改。
int * const p4;			//指向int型的const指针，指针变量存储的地址无法修改
const int * const p2;	//指向const int型的const指针，指针变量存储的地址以及地址存储的值均无法修改
4.3.4.2 const修饰的变量真的不能变吗
4.3.4.3 const究竟应该怎么用

4.3.7 指针和强制类型转换
4.3.7.1 变量的数据类型的含义
(1) C语言中的类型实际上就决定了一个数按照哪种方法转换成二进制编码，保存在内存中；同样的，C语言中的类型也决定了按照哪种解析方法对内存中的数进行解析。始终记住一点，内存只是一个存储空间，
存储0101码，不管这些0101码应该如何解析的，所以，我们在编程时，数据类型不能瞎胡乱搞（譬如按照int类型存储，却以float类型读取）。
分析几个题目：
按照int类型存储，却以float类型读取			//一定会乱码
按照int类型存储，却以char类型读取			//可能报错也可能不报错
按照int类型存储，却以short类型读取			//可能报错也可能不报错
按照float类型存储，却以double类型读取			//一定会乱码
(2) int float double是三种不兼容的类型，相互之间强制类型转换会出现乱码。
而相互兼容的类型(char short int long)之间强制转换时，不一定会报错。
指针类型是以地址解析方式去解析的；int型是以int解析方式解析的；float型是以float解析方式解析的；double型是以double解析方式解析的...相互之间解析方法不同，所以，
不兼容类型间强制转换会出现乱码的现象。

4.3.8 指针、数组和 sizeof运算符
(1) sizeof和+ — * /这些一样，都是运算符而不是函数，它的作用只是用来计算sizeof()括弧里面的变量或者数据类型所占的内存大小（以字节为单位）
(2) sizeof()存在的价值：由于在不同的平台下各种数据类型所占内存空间的大小不尽相同（例如int型在64位系统中为8字节，在32位系统中为4字节，在16位系统中为2字节等等），所以
需要使用sizeof来查看变量/数据类型所占内存空间大小。
4.8.3.1 char str[] = hello; sizeof(str); sizeof(str[0]); strlen(str);
4.3.8.2 char *p = str;		sizeof(p);		sizeof(*p)		strlen(p);
4.3.8.3 int n= 10；			sizeof(n);
4.3.8.4 int b[100];			sizeof(b);	
4.3.8.5 void fun(char b[100])		//数组作为形参时，只传递了首元素的首地址，也就是int型的指针，所以sizeof(b) = 4；数组作为形参传递不了数组的大小，数组大小可以用sizeof(a)/sizeof(a[0])表示。
		{
							sizeof(b);//形参char b[100] 和 char b[] 以及 char *b之间是完全等价的。
		}
4.3.8.6 
		#define DPCHAR char *;
		typedef char *TPCHAR;
		
		DPCHAR p1, p2;		//宏定义展开为：char *p1, p2; 所以p2是char型的变量，sizeof(p2) = 1;
		TPCHAR p3, p4;		//这里的TPCHAR就表示char *类型，表示char型的指针，这里展开就是：char *p3, *p4; 所以以后想定义多个指针变量时可以考虑一下typedef,超级好用。
		
4.3.9 指针和函数传参
4.3.9.1 int型变量传递形参时是把实参值赋值给形参变量的。
4.3.9.2 数组传递变量时时把首元素的首地址传给了形参变量，也称为传址函数，传的是指针。
4.3.9.3 结构体传递变量时，实参的各个成员把值赋值给形参的各个成员，有些类似于int型传参，一般来说，结构体都是很大的，通过赋值传递效率很低，因此传递结构体时应该传递结构体变量的地址，
在调用函数里通过解引用来使用结构体。
4.3.9.4 传值和传址
传值和传址都是实参把他的副本拷贝给了形参没有本质的区别，区别只在于传址的话可以通过解引用来访问并修改实参的变量值而已。

4.3.10 传入参数和传出参数
一个函数想输出多个值的时候，一般都是借助传出参数来实现的，因为函数的返回值只能返回一个值，远达不到要求。
区分输入参数和输出参数：
(1) 形参是普通变量时，一定是输入参数；
(2) 形参是指针时，可能是输入参数，也可能是输出参数。
一般程序员约定熟成的，在输入参数指针前面加const，如 char* strcpy(char *dest, const *source)。作为输入参数时，不允许改变值，作为输出参数时，可以允许改变值。
于是看别人的函数代码时，形参如果出现前面加const的指针，就是告诉你这个是输入参数，其他没加const的指针表明这个是输出参数，后续代码会用这个参数输出的内容的。